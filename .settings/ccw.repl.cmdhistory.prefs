cmdhistory=["(keys stemmer)" "stemmer" "(make-stemmer \\"looking\\")" "(\:word (make-stemmer \\"looking\\"))" "(doc make-stemmer)" "(require 'clojure.Repl)" "(require 'clojure.repl)" "(require 'clojure.REPL)" "(require 'clojure.core.repl)" "(clojure.repl/doc make-stemmer)" "(use 'clojure.repl)" "(doc make-stemmer)" "let [s (make-stemmer \\"all\\")]" "(let [s (make-stemmer \\"all\\")])" "s" "(\:word s)" "(\:index s)" "(def s (make-stemmer \\"all\\"))" "s" "(\:word s)" "(\:index s)" "(reset-index (\:word s))" "(\:index (reset-index (\:word s)))" "(< 1 2)" "(def st (struct stemmer \\"looking\\" 4))" "st" "(get-index st)" "(vec look)" "(vec \\"look\\")" "(\:name st)" "st" "(\:word st)" "st" "(subword st)" "(let a (subword st))" "(let [a (subword st)])" "(def a (subword st))" "(subword st)" "st" "(subword st)" "(\:word st)" "(get-index st)" "(subvec (\:word st) 0 4)" "(pop \\"all\\")" "(pop (vec \\"all))" "(pop (vec \\"all\\"))" "(def st (make-stemmer \\"looking\\" 4))" "(def st (make-stemmer))" "(def st (make-stemmer \\"looking\\"))" "st" "(subword st)" "(\:index st)" "st" "(index-char st)" "(pop-word (make-stemmer \\"looking\\"))" "st" "(pop-stemmer-on \\"ing\\" st)" "(type st)" "(pop-stemmer-on \\"ing\\" st)" "(defn pop-stemmer-on\\n  \\"This is an amalgam of a number of\\n  different functions\: pop (it walks\\n  through the \:word sequence using pop);\\n  drop-while (it drops items off while\\n  testing the sequence against drop-while);\\n  and maplist from Common Lisp (the\\n  predicate is tested against the entire\\n  current stemmer, not just the first\\n  element).\\"\\n  [predicate stemmer]\\n  (if (and (seq (\:word stemmer)) (predicate stemmer))\\n    (recur predicate (pop-word stemmer))\\n    stemmer))" "(pop-stemmer-on \\"ing\\" st)" "pop-stemmer-on" "st" "((contains? (\:word st) \\\\g)\\n  )" "(contains? (\:word st) \\\\g)" "(pop-word st)" "st" "(\= (peek (\:word st)) \\\\g)" "(pop-stemmer-on \#(\= (peek (\:word %1)) \\\\g) st)"]
eclipse.preferences.version=1
